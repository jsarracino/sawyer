#include <sawyer/MarkupRoff.h>
#include <sawyer/Assert.h>

#include <boost/algorithm/string/case_conv.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/regex.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/trim.hpp>
#include <boost/foreach.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/numeric/conversion/cast.hpp>
#include <boost/regex.hpp>

namespace Sawyer {
namespace Markup {


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Roff Formatters (man pages)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RoffFormatterPtr RoffFormatter::title(const std::string &pageName, const std::string &chapterNumber,
                                      const std::string &chapterName, const std::string &versionString,
                                      const std::string &dateString) {
    this->pageName(pageName);
    this->chapterNumber(chapterNumber);
    this->chapterName(chapterName);
    return version(versionString, dateString);
}

RoffFormatterPtr RoffFormatter::version(const std::string &versionString, const std::string &dateString) {
    this->versionString(versionString);
    this->dateString(dateString);                       // FIXME[Robb Matzke 2014-02-23]: use current date
    return self();
}

RoffFormatterPtr RoffFormatter::chapterNumber(int i) {
    chapterNumber_=boost::lexical_cast<std::string>(i); return self();
}

std::string RoffFormatter::escapeArg(const std::string &s) const {
    std::string retval;
    bool needQuotes = false;
    BOOST_FOREACH (char c, s) {
        if ('"'==c) {
            needQuotes = true;
            retval += "\\\"";
        } else if ('\\'==c) {
            needQuotes = true;
            retval += "\\\\";
        } else if (!isalnum(c)) {
            needQuotes = true;
            retval += c;
        } else {
            retval += c;
        }
    }
    if (needQuotes || retval.empty())
        retval = "\"" + retval + "\"";
    return retval;
}

std::string RoffFormatter::escapeText(const std::string &s) const {
    std::string retval;
    BOOST_FOREACH (char c, s) {
        switch (c) {
            case '-':
                retval += "\\-";
                break;
            default:
                retval += c;
                break;
        }
    }
    return retval;
}

void RoffFormatter::beginDocument(std::ostream &stream) {
    stream <<"'\\\" t\n"                                // not sure what this does, but see git-clone.1
           <<".\\\"    This file was automatically generated by Sawyer\n"
           <<".TH"
           <<" " <<escapeArg(pageName_)                 // header left and right, footer right
           <<" " <<escapeArg(chapterNumber_)            // part of the page name
           <<" " <<escapeArg(dateString_)               // footer center
           <<" " <<escapeArg(versionString_)            // footer left
           <<" " <<escapeArg(chapterName_)              // header center
           <<"\n"
           <<".ie \\n(.g .ds Aq \\(aq\n"                // see git-clone.1
           <<".el        .ds Aq\n"
           <<".nh\n"                                    // disable hyphenation
           <<".ad l\n"                                  // disable justifcation (align left only)
           <<"";
}

void RoffFormatter::endDocument(std::ostream &stream) {
    std::string str = bufferedOutput_.str();
    std::vector<std::string> lines;
#include <sawyer/WarningsOff.h>
    boost::split(lines, str, boost::is_any_of("\n"));
#include <sawyer/WarningsRestore.h>
    BOOST_FOREACH (std::string &line, lines)
        boost::trim(line);

    // Emit the lines with special handling for blank lines.  If a blank line is used as a paragraph separator, then emit it,
    // otherwise suppress it so it doesn't interfere with roff's vertical spacing.  A blank line is a paragraph separator only
    // when it occurs between lines that are not roff commands, which always start with a '.' in the first column.
    bool hadCommand = true;                             // last non-blank line was a roff command?
    for (size_t i=0; i<lines.size(); ++i) {
        if (lines[i].empty()) {
            if (!hadCommand && i+1<lines.size() && !lines[i+1].empty() && lines[i+1][0]!='.') {
                stream <<"\n";
            }
        } else {
            stream <<lines[i] <<"\n";
            hadCommand = !lines[i].empty() && '.'==lines[i][0];
        }
    }
}

void RoffFormatter::checkArgs(const TagPtr &tag, size_t nArgs, const TagArgs &args) const {
    if (args.size()!=nArgs) {
        std::ostringstream ss;
        ss <<"expected " <<nArgs <<" argument" <<(1==nArgs?"":"s") <<" for @" <<tag->name() <<" but got " <<args.size();
        throw std::runtime_error(ss.str());
    }
}

void RoffFormatter::checkIsInside(const TagPtr &tag, const std::string &required) const {
    BOOST_FOREACH (const TagPtr &inside, tagStack_) {
        if (inside->name() == required)
            return;
    }
    std::ostringstream ss;
    ss <<"@" <<tag->name() <<" must be enclosed inside " <<(tag->name()==required?"another ":"") <<"@" <<required;
    throw std::runtime_error(ss.str());
}

void RoffFormatter::checkNotInside(const TagPtr &tag, const std::string &prohibited) const {
    BOOST_FOREACH (const TagPtr &inside, tagStack_) {
        if (inside->name() == prohibited) {
            std::ostringstream ss;
            ss <<"@" <<tag->name() <<" is prohibited inside " <<(tag->name()==prohibited?"another ":"") <<"@" <<prohibited;
            throw std::runtime_error(ss.str());
        }
    }
}

void RoffFormatter::checkNotInArg(const TagPtr &tag) const {
    if (inArg_) {
        std::ostringstream ss;
        ss <<"@" <<tag->name() <<" is prohibited inside an nroff argument for @" <<inArg_->name();
        throw std::runtime_error(ss.str());
    }
}

void RoffFormatter::nextLine() {
    bufferedOutput_ <<"\n";
    startOfLine_ = true;
}

bool RoffFormatter::beginTag(std::ostream &stream, const TagPtr &tag, const TagArgs &args) {
    bool recurse = true;                                // allow children to recursively emit
    if (tag->name() == "section" || tag->name() == "subsection") {
        checkArgs(tag, 2, args);
        std::string cmd;
        int shouldConvertToUpper = 0;
        if (tag->name() == "section") {
            checkNotInside(tag, "section");
            checkNotInside(tag, "subsection");
            checkNotInside(tag, "namebullet");
            checkNotInArg(tag);
            cmd = ".SH";
            shouldConvertToUpper = 1;
        } else {
            ASSERT_require(tag->name() == "subsection");
            checkIsInside(tag, "section");
            checkNotInside(tag, "subsection");
            checkNotInside(tag, "namebullet");
            checkNotInArg(tag);
            cmd = ".SS";
        }
        tagStack_.push_back(tag);

        inArg_ = tag;
        bufferedOutput_ <<"\n";
        std::streampos shPosition = bufferedOutput_.tellp();
        bufferedOutput_ <<cmd <<" \"";
        convertToUpper_ += shouldConvertToUpper;
        args[0]->emit(stream, self());
        convertToUpper_ -= shouldConvertToUpper;
        bufferedOutput_ <<"\"";
        nextLine();
        clear(inArg_);

        // We don't want to emit an .SH/.SS command if there's no body, but since it's too late by now to go back and fix it,
        // and since we can't expect to have c++11 move semantics, the only way to undo the .SH/.SS command is to seek back and
        // overwrite it with an nroff comment. (Casting nonsense is for Microsoft's C++ compiler.)
        size_t startOfBody = boost::numeric_cast<size_t>((boost::uint64_t)bufferedOutput_.tellp());
        args[1]->emit(stream, self());
        if (boost::trim_copy(bufferedOutput_.str().substr(startOfBody)).empty()) {
            bufferedOutput_.seekp(shPosition);
            bufferedOutput_ <<".\\\"";
            bufferedOutput_.seekp(0, std::ios_base::end);
        }

        nextLine();
        recurse = false;

    } else if (tag->name() == "namebullet") {
        checkArgs(tag, 2, args);
        checkNotInside(tag, "namebullet");
        checkNotInArg(tag);
        tagStack_.push_back(tag);

        bufferedOutput_ <<"\n.TP";
        nextLine();
        inArg_ = tag;
        args[0]->emit(stream, self());
        clear(inArg_);

        nextLine();
        args[1]->emit(stream, self());
        nextLine();
        recurse = false;
        
    } else if (tag->name() == "bold") {
        checkArgs(tag, 1, args);
        checkNotInside(tag, "bold");
        checkNotInside(tag, "variable");
        checkNotInside(tag, "italic");
        tagStack_.push_back(tag);

        bufferedOutput_ <<"\\fB";
        args[0]->emit(stream, self());
        bufferedOutput_ <<"\\fR";
        recurse = false;

    } else if (tag->name() == "variable") {
        checkArgs(tag, 1, args);
        checkNotInside(tag, "bold");
        checkNotInside(tag, "variable");
        checkNotInside(tag, "italic");
        tagStack_.push_back(tag);

        bufferedOutput_ <<"\\fI";
        ++convertToUpper_;
        args[0]->emit(stream, self());
        --convertToUpper_;
        bufferedOutput_ <<"\\fR";
        recurse = false;

    } else if (tag->name() == "italic") {
        checkArgs(tag, 1, args);
        checkNotInside(tag, "bold");
        checkNotInside(tag, "variable");
        checkNotInside(tag, "italic");
        tagStack_.push_back(tag);

        bufferedOutput_ <<"\\fI";
        args[0]->emit(stream, self());
        bufferedOutput_ <<"\\fR";
        recurse = false;

    } else if (tag->name() == "comment") {
        checkArgs(tag, 1, args);
        checkNotInArg(tag);
        tagStack_.push_back(tag);

        inArg_ = tag;
        bufferedOutput_ <<".\\\" ";
        args[0]->emit(stream, self());
        nextLine();
        clear(inArg_);
        recurse = false;

    } else {
        throw std::runtime_error("unknown tag for nroff formatter: @" + tag->name());
    }
    return recurse;
}

void RoffFormatter::endTag(std::ostream &stream, const TagPtr &tag, const TagArgs &args) {
    ASSERT_forbid(tagStack_.empty());
    ASSERT_require(tagStack_.back()->name() == tag->name());
    tagStack_.pop_back();
}

void RoffFormatter::text(std::ostream &stream, const std::string &text) {
    std::string s = text;

    // boost::regex leadspace("^[ \t]+");
    // boost::erase_all_regex(s, leadspace);
    if (startOfLine_)
        boost::trim_left_if(s, boost::is_any_of(" \t\n"));

    //boost::regex trailspace("[ \t]+$");
    //boost::erase_all_regex(s, trailspace);

    boost::regex multispace("[ \t][ \t]+");
    boost::replace_all_regex(s, multispace, std::string(" "));

    if (convertToUpper_)
        boost::to_upper(s);
    s = escapeText(s);
    if (startOfLine_ && !s.empty() && '.'==s[0])
        s = "\\fR" + s;                                  // otherwise it looks like a command

    bufferedOutput_ <<s;

    if (!s.empty())
        startOfLine_ = false;
}


} // namespace
} // namespace
