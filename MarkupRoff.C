#include "MarkupRoff.h"
#include <boost/algorithm/string/case_conv.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/regex.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/trim.hpp>
#include <boost/foreach.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/regex.hpp>

namespace Sawyer {
namespace Markup {


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Roff Formatters (man pages)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RoffFormatterPtr RoffFormatter::title(const std::string &pageName, const std::string &chapterNumber,
                                      const std::string &chapterName, const std::string &versionString,
                                      const std::string &dateString) {
    this->pageName(pageName);
    this->chapterNumber(chapterNumber);
    this->chapterName(chapterName);
    return version(versionString, dateString);
}

RoffFormatterPtr RoffFormatter::version(const std::string &versionString, const std::string &dateString) {
    this->versionString(versionString);
    this->dateString(dateString);                       // FIXME[Robb Matzke 2014-02-23]: use current date
    return self();
}

RoffFormatterPtr RoffFormatter::chapterNumber(int i) {
    chapterNumber_=boost::lexical_cast<std::string>(i); return self();
}

std::string RoffFormatter::escapeArg(const std::string &s) const {
    std::string retval;
    bool needQuotes = false;
    BOOST_FOREACH (char c, s) {
        if ('"'==c) {
            needQuotes = true;
            retval += "\\\"";
        } else if ('\\'==c) {
            needQuotes = true;
            retval += "\\\\";
        } else if (!isalnum(c)) {
            needQuotes = true;
            retval += c;
        } else {
            retval += c;
        }
    }
    if (needQuotes || retval.empty())
        retval = "\"" + retval + "\"";
    return retval;
}

std::string RoffFormatter::escapeText(const std::string &s) const {
    std::string retval;
    BOOST_FOREACH (char c, s) {
        switch (c) {
            case '-': retval += "\\-"; break;
            default: retval += c; break;
        }
    }
    return retval;
}

void RoffFormatter::beginDocument(std::ostream &stream) {
    stream <<"'\\\" t\n"                                // not sure what this does, but see git-clone.1
           <<".\\\"    This file was automatically generated by Sawyer\n"
           <<".TH"
           <<" " <<escapeArg(pageName_)                 // header left and right, footer right
           <<" " <<escapeArg(chapterNumber_)            // part of the page name
           <<" " <<escapeArg(dateString_)               // footer center
           <<" " <<escapeArg(versionString_)            // footer left
           <<" " <<escapeArg(chapterName_)              // header center
           <<"\n"
           <<".ie \\n(.g .ds Aq \\(aq\n"                // see git-clone.1
           <<".el        .ds Aq\n"
           <<".nh\n"                                    // disable hyphenation
           <<".ad l\n"                                  // disable justifcation (align left only)
           <<"";
}

void RoffFormatter::endDocument(std::ostream &stream) {
    std::string str = bufferedOutput_.str();
    std::vector<std::string> lines;
    boost::split(lines, str, boost::is_any_of("\n"));
    BOOST_FOREACH (std::string &line, lines)
        boost::trim(line);

    // Emit the lines with special handling for blank lines.  If a blank line is used as a paragraph separator, then emit it,
    // otherwise suppress it so it doesn't interfere with roff's vertical spacing.  A blank line is a paragraph separator only
    // when it occurs between lines that are not roff commands, which always start with a '.' in the first column.
    bool hadCommand = true;                             // last non-blank line was a roff command?
    for (size_t i=0; i<lines.size(); ++i) {
        if (lines[i].empty()) {
            if (!hadCommand && i+1<lines.size() && !lines[i+1].empty() && lines[i+1][0]!='.') {
                stream <<"\n";
            }
        } else {
            stream <<lines[i] <<"\n";
            hadCommand = !lines[i].empty() && '.'==lines[i][0];
        }
    }
}

void RoffFormatter::checkArgs(const TagPtr &tag, size_t nArgs, const TagArgs &args) const {
    if (args.size()!=nArgs) {
        std::ostringstream ss;
        ss <<"expected " <<nArgs <<" argument" <<(1==nArgs?"":"s") <<" for @" <<tag->name() <<" but got " <<args.size();
        throw std::runtime_error(ss.str());
    }
}

void RoffFormatter::checkNotInside(const TagPtr &tag, const std::string &prohibited) const {
    BOOST_FOREACH (const TagPtr &inside, tagStack_) {
        if (inside->name() == prohibited) {
            std::ostringstream ss;
            ss <<"@" <<tag->name() <<" is prohibited inside " <<(inside->name()==prohibited?"another ":"") <<"@" <<prohibited;
            throw std::runtime_error(ss.str());
        }
    }
}

void RoffFormatter::checkNotInArg(const TagPtr &tag) const {
    if (inArg_) {
        std::ostringstream ss;
        ss <<"@" <<tag->name() <<" is prohibited inside an nroff argument for @" <<inArg_->name();
        throw std::runtime_error(ss.str());
    }
}

void RoffFormatter::nextLine() {
    if (!startOfLine_) {
        bufferedOutput_ <<"\n";
        startOfLine_ = true;
    }
}

bool RoffFormatter::beginTag(std::ostream &stream, const TagPtr &tag, const TagArgs &args) {
    bool recurse = true;                                // allow children to recursively emit
    if (tag->name() == "section") {
        checkArgs(tag, 2, args);
        checkNotInside(tag, "section");
        checkNotInside(tag, "namebullet");
        checkNotInArg(tag);

        inArg_ = tag;
        bufferedOutput_ <<"\n.SH \"";
        ++convertToUpper_;
        args[0]->emit(stream, self());
        --convertToUpper_;
        bufferedOutput_ <<"\"";
        nextLine();
        inArg_.reset();

        args[1]->emit(stream, self());
        bufferedOutput_ <<"\n";
        recurse = false;

    } else if (tag->name() == "namebullet") {
        checkArgs(tag, 2, args);
        checkNotInside(tag, "section");
        checkNotInside(tag, "namebullet");
        checkNotInArg(tag);

        bufferedOutput_ <<"\n.TP";
        nextLine();
        inArg_ = tag;
        args[0]->emit(stream, self());
        inArg_.reset();

        nextLine();
        args[1]->emit(stream, self());
        nextLine();
        recurse = false;
        
    } else if (tag->name() == "bold") {
        checkArgs(tag, 1, args);
        checkNotInside(tag, "bold");
        checkNotInside(tag, "variable");
        checkNotInside(tag, "italic");
        bufferedOutput_ <<"\\fB";
        args[0]->emit(stream, self());
        bufferedOutput_ <<"\\fR";
        recurse = false;

    } else if (tag->name() == "variable") {
        checkArgs(tag, 1, args);
        checkNotInside(tag, "bold");
        checkNotInside(tag, "variable");
        checkNotInside(tag, "italic");
        bufferedOutput_ <<"\\fI";
        ++convertToUpper_;
        args[0]->emit(stream, self());
        --convertToUpper_;
        bufferedOutput_ <<"\\fR";
        recurse = false;

    } else if (tag->name() == "italic") {
        checkArgs(tag, 1, args);
        checkNotInside(tag, "bold");
        checkNotInside(tag, "variable");
        checkNotInside(tag, "italic");
        bufferedOutput_ <<"\\fI";
        args[0]->emit(stream, self());
        bufferedOutput_ <<"\\fR";
        recurse = false;

    } else if (tag->name() == "comment") {
        checkArgs(tag, 1, args);
        checkNotInArg(tag);
        inArg_ = tag;
        bufferedOutput_ <<".\\\" ";
        args[0]->emit(stream, self());
        nextLine();
        inArg_.reset();
        recurse = false;

    } else {
        throw std::runtime_error("unknown tag for nroff formatter: @" + tag->name());
    }
    tagStack_.push_back(tag);
    return recurse;
}

void RoffFormatter::endTag(std::ostream &stream, const TagPtr &tag, const TagArgs &args) {
    assert(!tagStack_.empty());
    assert(tagStack_.back()->name() == tag->name());
    tagStack_.pop_back();
}

void RoffFormatter::text(std::ostream &stream, const std::string &text) {
    std::string s = text;

    // boost::regex leadspace("^[ \t]+");
    // boost::erase_all_regex(s, leadspace);
    if (startOfLine_)
        boost::trim_left_if(s, boost::is_any_of(" \t\n"));

    boost::regex trailspace("[ \t]+$");
    boost::erase_all_regex(s, trailspace);

    boost::regex multispace("[ \t][ \t]+");
    boost::replace_all_regex(s, multispace, std::string(" "));

    if (convertToUpper_)
        boost::to_upper(s);
    s = escapeText(s);
    bufferedOutput_ <<s;

    startOfLine_ = false;
}


} // namespace
} // namespace
